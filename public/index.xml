<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Postcard</title>
    <link>https://post.lilpilot.co/</link>
    <description>Recent content on Postcard</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 24 Jan 2021 16:07:02 +0800</lastBuildDate><atom:link href="https://post.lilpilot.co/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mockito饮用指南</title>
      <link>https://post.lilpilot.co/posts/mockito%E9%A5%AE%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sun, 24 Jan 2021 16:07:02 +0800</pubDate>
      
      <guid>https://post.lilpilot.co/posts/mockito%E9%A5%AE%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>介绍 Mockito是一个用于Java的开源测试mock框架，提供了非常清爽、简洁的API，这个名字来源于经典鸡尾酒 Mojito。
什么是mock？mock就是模拟，有了一个类或接口的定义，我们可以创建一个模拟对象来模拟它的行为，从而就不需要提供这个类或接口的真实实现。 这样在写单元测试的时候，我们只需要mock其他依赖，假设它们的预期返回，就可以专注于测试自己的实现逻辑。
听起来还不错吧，赶紧来尝一口试试。
先尝一口 引入 Mockito Mockito支持使用Gradle、Maven、Jar包引入，如果使用Spring Boot的话，spring-boot-starter-test默认已经集成了Mockito。
下文使用的Mockito，版本为3.6.0，项目代码基于Spring Boot。
入门操作 先来看一下官方文档上最简单的两个栗子
验证交互：
import static org.mockito.Mockito.*; // mock创建一个 List List mockedList = mock(List.class); // 调用mock对象的方法 mockedList.add(&amp;quot;one&amp;quot;); mockedList.clear(); // 可以直接验证方法被调用了 verify(mockedList).add(&amp;quot;one&amp;quot;); verify(mockedList).clear(); mock调用返回：
// mock创建一个 LinkedList LinkedList mockedList = mock(LinkedList.class); // 使用stub，假设mockedList.get(0)被调用时，会返回&amp;quot;first&amp;quot; when(mockedList.get(0)).thenReturn(&amp;quot;first&amp;quot;); // 控制台会打印&amp;quot;first&amp;quot; System.out.println(mockedList.get(0)); // 控制台会打印&amp;quot;null&amp;quot;，因为我们没有假设get(999)的返回值 System.out.println(mockedList.get(999)); 怎么样，看起来是不是很简单，语法也很贴近自然语言。
Mockito本质上是代理模式的应用，mock就是创建proxy对象，在proxy被调用前，使用stub的方式设置返回值，proxy还能记录并跟踪行为。
饮用搭配 doSomething() void方法或者spy对象，在mock行为时需要使用doThrow()、doAnswer()、doNothing()、doReturn()、doCallRealMethod()
注意区分mock和spy，mock就是完全代理，spy则是部分mock，可以调用真实方法，同时也能被跟踪验证
List list = new LinkedList(); List spy = spy(list); // 这里会抛出IndexOutOfBoundsException，因为调用了真实方法，而list实际上是个空列表 when(spy.get(0)).thenReturn(&amp;quot;foo&amp;quot;); // 使用doReturn()来设置spy.</description>
    </item>
    
    <item>
      <title>Archive</title>
      <link>https://post.lilpilot.co/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://post.lilpilot.co/archives/</guid>
      <description>archives</description>
    </item>
    
  </channel>
</rss>
