<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Mockito饮用指南 | Postcard</title>

<meta name="keywords" content="" />
<meta name="description" content="介绍 Mockito是一个用于Java的开源测试mock框架，提供了非常清爽、简洁的API，这个名字来源于经典鸡尾酒 Mojito。
什么是mock？mock就是模拟，有了一个类或接口的定义，我们可以创建一个模拟对象来模拟它的行为，从而就不需要提供这个类或接口的真实实现。 这样在写单元测试的时候，我们只需要mock其他依赖，假设它们的预期返回，就可以专注于测试自己的实现逻辑。
听起来还不错吧，赶紧来尝一口试试。
先尝一口 引入 Mockito Mockito支持使用Gradle、Maven、Jar包引入，如果使用Spring Boot的话，spring-boot-starter-test默认已经集成了Mockito。
下文使用的Mockito，版本为3.6.0，项目代码基于Spring Boot。
入门操作 先来看一下官方文档上最简单的两个栗子
验证交互：
import static org.mockito.Mockito.*; // mock创建一个 List List mockedList = mock(List.class); // 调用mock对象的方法 mockedList.add(&quot;one&quot;); mockedList.clear(); // 可以直接验证方法被调用了 verify(mockedList).add(&quot;one&quot;); verify(mockedList).clear(); mock调用返回：
// mock创建一个 LinkedList LinkedList mockedList = mock(LinkedList.class); // 使用stub，假设mockedList.get(0)被调用时，会返回&quot;first&quot; when(mockedList.get(0)).thenReturn(&quot;first&quot;); // 控制台会打印&quot;first&quot; System.out.println(mockedList.get(0)); // 控制台会打印&quot;null&quot;，因为我们没有假设get(999)的返回值 System.out.println(mockedList.get(999)); 怎么样，看起来是不是很简单，语法也很贴近自然语言。
Mockito本质上是代理模式的应用，mock就是创建proxy对象，在proxy被调用前，使用stub的方式设置返回值，proxy还能记录并跟踪行为。
饮用搭配 doSomething() void方法或者spy对象，在mock行为时需要使用doThrow()、doAnswer()、doNothing()、doReturn()、doCallRealMethod()
注意区分mock和spy，mock就是完全代理，spy则是部分mock，可以调用真实方法，同时也能被跟踪验证
List list = new LinkedList(); List spy = spy(list); // 这里会抛出IndexOutOfBoundsException，因为调用了真实方法，而list实际上是个空列表 when(spy.get(0)).thenReturn(&quot;foo&quot;); // 使用doReturn()来设置spy.">
<meta name="author" content="">
<link rel="canonical" href="https://post.lilpilot.co/posts/mockito%E9%A5%AE%E7%94%A8%E6%8C%87%E5%8D%97/" />
<link href="/assets/css/stylesheet.min.9fcc3f6054391fb578ab4f551fff2ff13cfd725f9aae09a65f74ae65a4011251.css" integrity="sha256-n8w/YFQ5H7V4q09VH/8v8Tz9cl&#43;argmmX3SuZaQBElE=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://post.lilpilot.co/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://post.lilpilot.co/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://post.lilpilot.co/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://post.lilpilot.co/apple-touch-icon.png">
<link rel="mask-icon" href="https://post.lilpilot.co/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />


<meta property="og:title" content="Mockito饮用指南" />
<meta property="og:description" content="介绍 Mockito是一个用于Java的开源测试mock框架，提供了非常清爽、简洁的API，这个名字来源于经典鸡尾酒 Mojito。
什么是mock？mock就是模拟，有了一个类或接口的定义，我们可以创建一个模拟对象来模拟它的行为，从而就不需要提供这个类或接口的真实实现。 这样在写单元测试的时候，我们只需要mock其他依赖，假设它们的预期返回，就可以专注于测试自己的实现逻辑。
听起来还不错吧，赶紧来尝一口试试。
先尝一口 引入 Mockito Mockito支持使用Gradle、Maven、Jar包引入，如果使用Spring Boot的话，spring-boot-starter-test默认已经集成了Mockito。
下文使用的Mockito，版本为3.6.0，项目代码基于Spring Boot。
入门操作 先来看一下官方文档上最简单的两个栗子
验证交互：
import static org.mockito.Mockito.*; // mock创建一个 List List mockedList = mock(List.class); // 调用mock对象的方法 mockedList.add(&quot;one&quot;); mockedList.clear(); // 可以直接验证方法被调用了 verify(mockedList).add(&quot;one&quot;); verify(mockedList).clear(); mock调用返回：
// mock创建一个 LinkedList LinkedList mockedList = mock(LinkedList.class); // 使用stub，假设mockedList.get(0)被调用时，会返回&quot;first&quot; when(mockedList.get(0)).thenReturn(&quot;first&quot;); // 控制台会打印&quot;first&quot; System.out.println(mockedList.get(0)); // 控制台会打印&quot;null&quot;，因为我们没有假设get(999)的返回值 System.out.println(mockedList.get(999)); 怎么样，看起来是不是很简单，语法也很贴近自然语言。
Mockito本质上是代理模式的应用，mock就是创建proxy对象，在proxy被调用前，使用stub的方式设置返回值，proxy还能记录并跟踪行为。
饮用搭配 doSomething() void方法或者spy对象，在mock行为时需要使用doThrow()、doAnswer()、doNothing()、doReturn()、doCallRealMethod()
注意区分mock和spy，mock就是完全代理，spy则是部分mock，可以调用真实方法，同时也能被跟踪验证
List list = new LinkedList(); List spy = spy(list); // 这里会抛出IndexOutOfBoundsException，因为调用了真实方法，而list实际上是个空列表 when(spy.get(0)).thenReturn(&quot;foo&quot;); // 使用doReturn()来设置spy." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://post.lilpilot.co/posts/mockito%E9%A5%AE%E7%94%A8%E6%8C%87%E5%8D%97/" />
<meta property="article:published_time" content="2021-01-24T16:07:02+08:00" />
<meta property="article:modified_time" content="2021-01-24T16:07:02+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Mockito饮用指南"/>
<meta name="twitter:description" content="介绍 Mockito是一个用于Java的开源测试mock框架，提供了非常清爽、简洁的API，这个名字来源于经典鸡尾酒 Mojito。
什么是mock？mock就是模拟，有了一个类或接口的定义，我们可以创建一个模拟对象来模拟它的行为，从而就不需要提供这个类或接口的真实实现。 这样在写单元测试的时候，我们只需要mock其他依赖，假设它们的预期返回，就可以专注于测试自己的实现逻辑。
听起来还不错吧，赶紧来尝一口试试。
先尝一口 引入 Mockito Mockito支持使用Gradle、Maven、Jar包引入，如果使用Spring Boot的话，spring-boot-starter-test默认已经集成了Mockito。
下文使用的Mockito，版本为3.6.0，项目代码基于Spring Boot。
入门操作 先来看一下官方文档上最简单的两个栗子
验证交互：
import static org.mockito.Mockito.*; // mock创建一个 List List mockedList = mock(List.class); // 调用mock对象的方法 mockedList.add(&quot;one&quot;); mockedList.clear(); // 可以直接验证方法被调用了 verify(mockedList).add(&quot;one&quot;); verify(mockedList).clear(); mock调用返回：
// mock创建一个 LinkedList LinkedList mockedList = mock(LinkedList.class); // 使用stub，假设mockedList.get(0)被调用时，会返回&quot;first&quot; when(mockedList.get(0)).thenReturn(&quot;first&quot;); // 控制台会打印&quot;first&quot; System.out.println(mockedList.get(0)); // 控制台会打印&quot;null&quot;，因为我们没有假设get(999)的返回值 System.out.println(mockedList.get(999)); 怎么样，看起来是不是很简单，语法也很贴近自然语言。
Mockito本质上是代理模式的应用，mock就是创建proxy对象，在proxy被调用前，使用stub的方式设置返回值，proxy还能记录并跟踪行为。
饮用搭配 doSomething() void方法或者spy对象，在mock行为时需要使用doThrow()、doAnswer()、doNothing()、doReturn()、doCallRealMethod()
注意区分mock和spy，mock就是完全代理，spy则是部分mock，可以调用真实方法，同时也能被跟踪验证
List list = new LinkedList(); List spy = spy(list); // 这里会抛出IndexOutOfBoundsException，因为调用了真实方法，而list实际上是个空列表 when(spy.get(0)).thenReturn(&quot;foo&quot;); // 使用doReturn()来设置spy."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Mockito饮用指南",
  "name": "Mockito饮用指南",
  "description": "介绍 Mockito是一个用于Java的开源测试mock框架，提供了非常清爽、简洁的API，这个名字来源于经典鸡尾酒 Mojito。\n什么是mock？mock就是模拟，有了一个类或接口的定义，我们可以创建一个模拟对象来模拟它的行为，从而就不需要提供这个类或接口的真实实现。 这样在写单元测试的时候，我们只需要mock其他依赖，假设它们的预期返回，就可以专注于测 …",
  "keywords": [
    
  ],
  "articleBody": "介绍 Mockito是一个用于Java的开源测试mock框架，提供了非常清爽、简洁的API，这个名字来源于经典鸡尾酒 Mojito。\n什么是mock？mock就是模拟，有了一个类或接口的定义，我们可以创建一个模拟对象来模拟它的行为，从而就不需要提供这个类或接口的真实实现。 这样在写单元测试的时候，我们只需要mock其他依赖，假设它们的预期返回，就可以专注于测试自己的实现逻辑。\n听起来还不错吧，赶紧来尝一口试试。\n先尝一口 引入 Mockito Mockito支持使用Gradle、Maven、Jar包引入，如果使用Spring Boot的话，spring-boot-starter-test默认已经集成了Mockito。\n下文使用的Mockito，版本为3.6.0，项目代码基于Spring Boot。\n入门操作 先来看一下官方文档上最简单的两个栗子\n验证交互：\nimport static org.mockito.Mockito.*; // mock创建一个 List List mockedList = mock(List.class); // 调用mock对象的方法 mockedList.add(\"one\"); mockedList.clear(); // 可以直接验证方法被调用了 verify(mockedList).add(\"one\"); verify(mockedList).clear(); mock调用返回：\n// mock创建一个 LinkedList LinkedList mockedList = mock(LinkedList.class); // 使用stub，假设mockedList.get(0)被调用时，会返回\"first\" when(mockedList.get(0)).thenReturn(\"first\"); // 控制台会打印\"first\" System.out.println(mockedList.get(0)); // 控制台会打印\"null\"，因为我们没有假设get(999)的返回值 System.out.println(mockedList.get(999)); 怎么样，看起来是不是很简单，语法也很贴近自然语言。\nMockito本质上是代理模式的应用，mock就是创建proxy对象，在proxy被调用前，使用stub的方式设置返回值，proxy还能记录并跟踪行为。\n饮用搭配 doSomething() void方法或者spy对象，在mock行为时需要使用doThrow()、doAnswer()、doNothing()、doReturn()、doCallRealMethod()\n注意区分mock和spy，mock就是完全代理，spy则是部分mock，可以调用真实方法，同时也能被跟踪验证\nList list = new LinkedList(); List spy = spy(list); // 这里会抛出IndexOutOfBoundsException，因为调用了真实方法，而list实际上是个空列表 when(spy.get(0)).thenReturn(\"foo\"); // 使用doReturn()来设置spy.get(0)的模拟返回 doReturn(\"foo\").when(spy).get(0); 使用ArgumentCapture来捕获并验证入参 仅验证行为还不够，如果还需要验证接口调用入参，可以使用ArgumentCapture\n// 初始化ArgumentCaptor ArgumentCaptor orderArgumentCaptor = ArgumentCaptor.forClass(Order.class); // 在调用处传入ArgumentCaptor.capture() verify(orderDAO, timeout(1)).update(orderArgumentCaptor.capture()); // orderArgumentCaptor捕获了刚才调用时传入的order参数，通过getValue()获取具体参数对象 Order updatedOrder = orderArgumentCaptor.getValue(); assertEquals(updatedOrder.getStatus(), \"processing\"); 实用注解 使用@Mock、@Spy、@InjectMocks注解，可以很方便地mock对象并注入\n@InjectMocks会尝试通过构造器、setter、字段注入使用@Mock、@Spy注解标识的对象\npublic class MockitoTest { /** * PostService依赖了PostRepository * 使用注解mock了PostRepository，并注入PostService中，不再需要手动设置 */ @Mock PostRepository postRepository; @InjectMocks PostService postService; } @Captor注解可以方便地创建ArgumentCaptor\n@Captor ArgumentCaptor orderArgumentCaptor; @Test public void test() { /** * @Captor可以替代以下写法: * ArgumentCaptor orderArgumentCaptor = ArgumentCaptor.forClass(Order.class); */ verify(orderDAO, timeout(1)).update(orderArgumentCaptor.capture()); } BDD BDD即行为驱动开发（Behavior-Driven Development），按照格式描述用例场景，Mockito提供了BDD的语法糖，可以很直接地按BDD语法(given when then)写test case\nimport static org.mockito.BDDMockito.*; Seller seller = mock(Seller.class); Shop shop = new Shop(seller); public void shouldBuyBread() throws Exception { //given given(seller.askForBread()).willReturn(new Bread()); //when Goods goods = shop.buyBread(); //then assertThat(goods, containBread()); } 实践一下 一个很简单的业务场景，OrderService提供下订单功能，通过OrderDAO查询并更新Order状态，然后调用OperateLogService保存操作信息。\n /** * 订单类 */ @Data public class Order { private Long id; private String status; } /** * 订单DAO接口，定义了查询、更新方法 */ public interface OrderDAO { Order findById(Long orderId); void update(Order order); } /** * 操作记录服务，定义了增加操作记录方法 */ public interface OperateLogService { void addRecord(Long orderId, String message); } /** * 订单服务 */ public class OrderService { private OperateLogService operateLogService; private OrderDAO orderDAO; @Autowired public void setOperateLogService(OperateLogService operateLogService) { this.operateLogService = operateLogService; } @Autowired public void setOrderDAO(OrderDAO orderDAO) { this.orderDAO = orderDAO; } /** * 下订单操作，更新订单状态并保存，添加操作记录 * @param orderId 订单id */ public void placeOrder(Long orderId) { Order order = orderDAO.findById(orderId); if (order == null) { throw new RuntimeException(\"订单不存在\"); } order.setStatus(\"processing\"); orderDAO.update(order); operateLogService.addRecord(orderId, \"创建订单\"); } } 这个例子中，我们需要为OrderService.placeOrder()这个方法写单元测试。\n分析一下实现逻辑，查询order后需要判断order是否存在，这里就需要一个单独的test case来验证异常抛出；\norderDAO.update()是需要验证的重点，该方法需要被正常调用，同时订单的状态会变更为\"processing\"；OperateLogService是第三方服务，在下单的逻辑中不需要关心其具体的实现逻辑，直接mock，只需要验证被正常调用即可。\nimport static org.junit.Assert.*; import static org.mockito.Mockito.*; import static org.mockito.BDDMockito.*; public class OrderServiceTest { @Mock OrderDAO orderDAO; @Mock OperateLogService operateLogService; @InjectMocks OrderService orderService; @Captor ArgumentCaptor orderArgumentCaptor; @Test public void place_order_should_throw_exception_when_order_not_exist() { // given // mock查询方法返回空值 given(orderDAO.findById(anyLong())) .willReturn(null); // when // then // 验证会抛出异常 RuntimeException exception = assertThrows(RuntimeException.class, () - orderService.placeOrder(1L)); assertEquals(exception.getMessage(), \"订单不存在\"); } @Test public void place_order_should_update_order_status_then_save() { // given // mock查询方法返回一个order long orderId = 1L; Order order = new Order(); order.setId(orderId); order.setStatus(\"init\"); given(orderDAO.findById(orderId)) .willReturn(order); // when // 下订单操作 orderService.placeOrder(1L); // then // 验证orderDAO.update被调用一次 then(orderDAO).should(times(1)).update(orderArgumentCaptor.capture()); // 验证订单状态被更新 Order updatedOrder = orderArgumentCaptor.getValue(); assertEquals(updatedOrder.getId(), orderId); assertEquals(updatedOrder.getStatus(), \"processing\"); // 验证保存了操作信息 then(operateLogService).should().addRecord(eq(orderId), anyString()); } } 这个单元测试中使用了之前提到的BDD、注解和参数捕获器，测试代码清晰易懂，写起来也很方便。\n再加点料 搭配AssertJ风味更佳 相比于JUnit的断言，AssertJ提供了更流畅的断言API，而且方便扩展\n import static org.assertj.core.api.Assertions.*; assertEquals(expected, actual); - assertThat(actual).isEqualTo(expected); assertThatThrownBy(() - {methodWillThrow();}) .isInstanceOf(SomeException.class) .hasMessage(\"参数不能为空\"); PowerMockito Mockito不支持mock测试static方法、构造器、final方法、private方法等，可以使用PowerMock来解决。\nPowerMock也提供了PowerMockito来配合Mockito的API使用。\n注: Mockito 2.1.0已支持mock final methods/class\norderService = PowerMockito.spy(orderService); PowerMockito.doReturn(any()).when(orderService, \"privateMethod\", any()); PowerMockito.verifyPrivate(orderService).invoke(\"privateMethod\", any()); TDD TDD即测试驱动开发（Test-Driven Development）。\n回顾一下常见的开发流程，先需求分析，然后分解任务，再实现具体逻辑，最后写单测验证。把单元测试放在最后一步，容易遗漏琐碎的改动点，而且一些设计上的问题暴露地比较晚，随着需求不断迭代，开发人员也很容易产生惰性，“忘记”写单元测试。\n回过来看整个流程，在分解任务的时候，其实就是实现具体逻辑前的的设计过程；这个阶段会设计需要的类、方法以及他们之间的交互，这些设计方案应该是落地的，并且是可验证的。\n因此可以采用TDD，把编写测试用例的流程前提至设计阶段，分解后的任务单元，其实就是一个或多个可验证的测试用例，在编写测试用例的时候，可以”强迫“自己思考设计的合理性，然后立刻实现并验证。\nTDD时，保持测试-实现-重构(红-绿-黄)的节奏，建议在IDE上配好顺手的rerun test的快捷键。\n总结 Mockito简明易懂的API，结合上文提到的一些实践，写单测不再费时费力，赶紧试试吧。\n🍻 cheers~\n 参考 Mockito官方文档\nAssertJ官方文档\nPowerMock官方文档\n",
  "wordCount" : "434",
  "inLanguage": "en",
  "datePublished": "2021-01-24T16:07:02+08:00",
  "dateModified": "2021-01-24T16:07:02+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://post.lilpilot.co/posts/mockito%E9%A5%AE%E7%94%A8%E6%8C%87%E5%8D%97/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Postcard",
    "logo": {
      "@type": "ImageObject",
      "url": "https://post.lilpilot.co/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://post.lilpilot.co/" accesskey="h" title="Postcard (Alt + H)">Postcard</a>
            <span class="logo-switches">
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://post.lilpilot.co/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://post.lilpilot.co/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Mockito饮用指南
    </h1>
    <div class="post-description">
      
    </div>
    <div class="post-meta">January 24, 2021

    </div>
  </header> 

  <div class="post-content">
<h1 id="介绍">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍">#</a></h1>
<p>Mockito是一个用于Java的开源测试mock框架，提供了非常清爽、简洁的API，这个名字来源于经典鸡尾酒 Mojito。</p>
<p>什么是mock？mock就是模拟，有了一个类或接口的定义，我们可以创建一个模拟对象来模拟它的行为，从而就不需要提供这个类或接口的真实实现。
这样在写单元测试的时候，我们只需要mock其他依赖，假设它们的预期返回，就可以专注于测试自己的实现逻辑。</p>
<p>听起来还不错吧，赶紧来尝一口试试。</p>
<h1 id="先尝一口">先尝一口<a hidden class="anchor" aria-hidden="true" href="#先尝一口">#</a></h1>
<h2 id="引入-mockito">引入 Mockito<a hidden class="anchor" aria-hidden="true" href="#引入-mockito">#</a></h2>
<p>Mockito支持使用Gradle、Maven、Jar包引入，如果使用Spring Boot的话，spring-boot-starter-test默认已经集成了Mockito。</p>
<p>下文使用的Mockito，版本为3.6.0，项目代码基于Spring Boot。</p>
<h2 id="入门操作">入门操作<a hidden class="anchor" aria-hidden="true" href="#入门操作">#</a></h2>
<p>先来看一下官方文档上最简单的两个栗子</p>
<p>验证交互：</p>
<pre><code>import static org.mockito.Mockito.*;

// mock创建一个 List
List mockedList = mock(List.class);

// 调用mock对象的方法
mockedList.add(&quot;one&quot;);
mockedList.clear();

// 可以直接验证方法被调用了
verify(mockedList).add(&quot;one&quot;);
verify(mockedList).clear();
</code></pre><p>mock调用返回：</p>
<pre><code>// mock创建一个 LinkedList
LinkedList mockedList = mock(LinkedList.class);

// 使用stub，假设mockedList.get(0)被调用时，会返回&quot;first&quot;
when(mockedList.get(0)).thenReturn(&quot;first&quot;);

// 控制台会打印&quot;first&quot;
System.out.println(mockedList.get(0));

// 控制台会打印&quot;null&quot;，因为我们没有假设get(999)的返回值
System.out.println(mockedList.get(999));

</code></pre><p>怎么样，看起来是不是很简单，语法也很贴近自然语言。</p>
<p>Mockito本质上是代理模式的应用，mock就是创建proxy对象，在proxy被调用前，使用stub的方式设置返回值，proxy还能记录并跟踪行为。</p>
<h1 id="饮用搭配">饮用搭配<a hidden class="anchor" aria-hidden="true" href="#饮用搭配">#</a></h1>
<h2 id="dosomething">doSomething()<a hidden class="anchor" aria-hidden="true" href="#dosomething">#</a></h2>
<p>void方法或者spy对象，在mock行为时需要使用doThrow()、doAnswer()、doNothing()、doReturn()、doCallRealMethod()</p>
<p>注意区分mock和spy，mock就是完全代理，spy则是部分mock，可以调用真实方法，同时也能被跟踪验证</p>
<pre><code>List list = new LinkedList();
List spy = spy(list);

// 这里会抛出IndexOutOfBoundsException，因为调用了真实方法，而list实际上是个空列表
when(spy.get(0)).thenReturn(&quot;foo&quot;);

// 使用doReturn()来设置spy.get(0)的模拟返回
doReturn(&quot;foo&quot;).when(spy).get(0);
</code></pre><h2 id="使用argumentcapture来捕获并验证入参">使用ArgumentCapture来捕获并验证入参<a hidden class="anchor" aria-hidden="true" href="#使用argumentcapture来捕获并验证入参">#</a></h2>
<p>仅验证行为还不够，如果还需要验证接口调用入参，可以使用ArgumentCapture</p>
<pre><code>// 初始化ArgumentCaptor
ArgumentCaptor&lt;Order&gt; orderArgumentCaptor = ArgumentCaptor.forClass(Order.class);

// 在调用处传入ArgumentCaptor.capture()
verify(orderDAO, timeout(1)).update(orderArgumentCaptor.capture());

// orderArgumentCaptor捕获了刚才调用时传入的order参数，通过getValue()获取具体参数对象
Order updatedOrder = orderArgumentCaptor.getValue();

assertEquals(updatedOrder.getStatus(), &quot;processing&quot;);
</code></pre><h2 id="实用注解">实用注解<a hidden class="anchor" aria-hidden="true" href="#实用注解">#</a></h2>
<p>使用@Mock、@Spy、@InjectMocks注解，可以很方便地mock对象并注入</p>
<p>@InjectMocks会尝试通过构造器、setter、字段注入使用@Mock、@Spy注解标识的对象</p>
<pre><code>public class MockitoTest {

    /**
     * PostService依赖了PostRepository
     * 使用注解mock了PostRepository，并注入PostService中，不再需要手动设置
     */
    @Mock
    PostRepository postRepository;
    @InjectMocks
    PostService postService;

}
</code></pre><p>@Captor注解可以方便地创建ArgumentCaptor</p>
<pre><code>@Captor
ArgumentCaptor&lt;Order&gt; orderArgumentCaptor;

@Test
public void test() {

    /**
     * @Captor可以替代以下写法:
     * ArgumentCaptor&lt;Order&gt; orderArgumentCaptor = ArgumentCaptor.forClass(Order.class);
     */
    verify(orderDAO, timeout(1)).update(orderArgumentCaptor.capture());

}
</code></pre><h2 id="bdd">BDD<a hidden class="anchor" aria-hidden="true" href="#bdd">#</a></h2>
<p>BDD即行为驱动开发（Behavior-Driven Development），按照格式描述用例场景，Mockito提供了BDD的语法糖，可以很直接地按BDD语法(given when then)写test case</p>
<pre><code>import static org.mockito.BDDMockito.*;

Seller seller = mock(Seller.class);
Shop shop = new Shop(seller);

public void shouldBuyBread() throws Exception {
    //given
    given(seller.askForBread()).willReturn(new Bread());

    //when
    Goods goods = shop.buyBread();

    //then
    assertThat(goods, containBread());
}
</code></pre><h1 id="实践一下">实践一下<a hidden class="anchor" aria-hidden="true" href="#实践一下">#</a></h1>
<p>一个很简单的业务场景，OrderService提供下订单功能，通过OrderDAO查询并更新Order状态，然后调用OperateLogService保存操作信息。</p>
<pre><code>
/**
 * 订单类
 */
@Data
public class Order {
    private Long id;
    private String status;
}

/**
 * 订单DAO接口，定义了查询、更新方法
 */
public interface OrderDAO {
    Order findById(Long orderId);
    void update(Order order);
}

/**
 * 操作记录服务，定义了增加操作记录方法
 */
public interface OperateLogService {
    void addRecord(Long orderId, String message);
}

/**
 * 订单服务
 */
public class OrderService {

    private OperateLogService operateLogService;
    private OrderDAO orderDAO;

    @Autowired
    public void setOperateLogService(OperateLogService operateLogService) {
        this.operateLogService = operateLogService;
    }

    @Autowired
    public void setOrderDAO(OrderDAO orderDAO) {
        this.orderDAO = orderDAO;
    }

    /**
     * 下订单操作，更新订单状态并保存，添加操作记录
     * @param orderId 订单id
     */
    public void placeOrder(Long orderId) {
        Order order = orderDAO.findById(orderId);
        if (order == null) {
            throw new RuntimeException(&quot;订单不存在&quot;);
        }
        order.setStatus(&quot;processing&quot;);
        orderDAO.update(order);
        operateLogService.addRecord(orderId, &quot;创建订单&quot;);
    }
}

</code></pre><p>这个例子中，我们需要为OrderService.placeOrder()这个方法写单元测试。</p>
<p>分析一下实现逻辑，查询order后需要判断order是否存在，这里就需要一个单独的test case来验证异常抛出；</p>
<p>orderDAO.update()是需要验证的重点，该方法需要被正常调用，同时订单的状态会变更为&quot;processing&quot;；OperateLogService是第三方服务，在下单的逻辑中不需要关心其具体的实现逻辑，直接mock，只需要验证被正常调用即可。</p>
<pre><code>import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
import static org.mockito.BDDMockito.*;

public class OrderServiceTest {

    @Mock
    OrderDAO orderDAO;
    @Mock
    OperateLogService operateLogService;
    @InjectMocks
    OrderService orderService;

    @Captor
    ArgumentCaptor&lt;Order&gt; orderArgumentCaptor;

    @Test
    public void place_order_should_throw_exception_when_order_not_exist() {
        // given
        // mock查询方法返回空值
        given(orderDAO.findById(anyLong()))
                .willReturn(null);

        // when
        // then
        // 验证会抛出异常
        RuntimeException exception = assertThrows(RuntimeException.class, () -&gt; orderService.placeOrder(1L));
        assertEquals(exception.getMessage(), &quot;订单不存在&quot;);

    }

    @Test
    public void place_order_should_update_order_status_then_save() {
        // given
        // mock查询方法返回一个order
        long orderId = 1L;
        Order order = new Order();
        order.setId(orderId);
        order.setStatus(&quot;init&quot;);
        given(orderDAO.findById(orderId))
                .willReturn(order);

        // when
        // 下订单操作
        orderService.placeOrder(1L);

        // then
        // 验证orderDAO.update被调用一次
        then(orderDAO).should(times(1)).update(orderArgumentCaptor.capture());
        // 验证订单状态被更新
        Order updatedOrder = orderArgumentCaptor.getValue();
        assertEquals(updatedOrder.getId(), orderId);
        assertEquals(updatedOrder.getStatus(), &quot;processing&quot;);
        // 验证保存了操作信息
        then(operateLogService).should().addRecord(eq(orderId), anyString());
    }
}

</code></pre><p>这个单元测试中使用了之前提到的BDD、注解和参数捕获器，测试代码清晰易懂，写起来也很方便。</p>
<h1 id="再加点料">再加点料<a hidden class="anchor" aria-hidden="true" href="#再加点料">#</a></h1>
<h2 id="搭配assertj风味更佳">搭配AssertJ风味更佳<a hidden class="anchor" aria-hidden="true" href="#搭配assertj风味更佳">#</a></h2>
<p>相比于JUnit的断言，AssertJ提供了更流畅的断言API，而且方便扩展</p>
<pre><code>
import static org.assertj.core.api.Assertions.*;

assertEquals(expected, actual);
-&gt;
assertThat(actual).isEqualTo(expected);
assertThatThrownBy(() -&gt; {methodWillThrow();})
    .isInstanceOf(SomeException.class)
    .hasMessage(&quot;参数不能为空&quot;);
</code></pre><h2 id="powermockito">PowerMockito<a hidden class="anchor" aria-hidden="true" href="#powermockito">#</a></h2>
<p>Mockito不支持mock测试static方法、构造器、final方法、private方法等，可以使用PowerMock来解决。</p>
<p>PowerMock也提供了PowerMockito来配合Mockito的API使用。</p>
<p>注: Mockito 2.1.0已支持mock final methods/class</p>
<pre><code>orderService = PowerMockito.spy(orderService);
PowerMockito.doReturn(any()).when(orderService, &quot;privateMethod&quot;, any());
PowerMockito.verifyPrivate(orderService).invoke(&quot;privateMethod&quot;, any());
</code></pre><h2 id="tdd">TDD<a hidden class="anchor" aria-hidden="true" href="#tdd">#</a></h2>
<p>TDD即测试驱动开发（Test-Driven Development）。</p>
<p>回顾一下常见的开发流程，先需求分析，然后分解任务，再实现具体逻辑，最后写单测验证。把单元测试放在最后一步，容易遗漏琐碎的改动点，而且一些设计上的问题暴露地比较晚，随着需求不断迭代，开发人员也很容易产生惰性，“忘记”写单元测试。</p>
<p>回过来看整个流程，在分解任务的时候，其实就是实现具体逻辑前的的设计过程；这个阶段会设计需要的类、方法以及他们之间的交互，这些设计方案应该是落地的，并且是可验证的。</p>
<p>因此可以采用TDD，把编写测试用例的流程前提至设计阶段，分解后的任务单元，其实就是一个或多个可验证的测试用例，在编写测试用例的时候，可以”强迫“自己思考设计的合理性，然后立刻实现并验证。</p>
<p>TDD时，保持测试-&gt;实现-&gt;重构(红-&gt;绿-&gt;黄)的节奏，建议在IDE上配好顺手的rerun test的快捷键。</p>
<h1 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h1>
<p>Mockito简明易懂的API，结合上文提到的一些实践，写单测不再费时费力，赶紧试试吧。</p>
<p>🍻 cheers~</p>
<hr>
<h1 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h1>
<p><a href="https://site.mockito.org/">Mockito官方文档</a></p>
<p><a href="http://joel-costigliola.github.io/assertj/index.html">AssertJ官方文档</a></p>
<p><a href="https://github.com/powermock/powermock/wiki">PowerMock官方文档</a></p>

</div>
  <footer class="post-footer">
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://post.lilpilot.co/">Postcard</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>

</body>

</html>
